rd1 <- rowData(tse1)
protein_coding <- rd2[any(rd2$transcript_type == "protein_coding"),]
head(rev(sort(table(unlist(protein_coding$transcript_id)))),30)
features
miRNA
tRNA
genome
names(genome)
ge <- genome[1:21]
ge
ge[tx]
ge <- genome[1:19]
ge[tx]
ge[tx[1,]]
ge
getSeq(ge, tx[1,])
getSeq(ge, tx[2,])
getSeq(ge, tx[2,0])
getSeq(ge, tx[3,0])
getSeq(ge, tx[4,0])
getSeq(ge, tx[5,0])
getSeq(ge, tx[6,0])
getSeq(ge, tx[7,0])
getSeq(ge, tx[8,0])
getSeq(ge, tx[9,0])
getSeq(ge, tx[19,0])
ge
tx
tx[tx$tx_biotype == "protein_coding"]
ge[tx[tx$tx_biotype == "protein_coding"]]
ge[tx[tx$tx_biotype == "protein_coding",2]]
ge[tx[tx$tx_biotype == "protein_coding"]]
ge[tx[tx$tx_biotype == "protein_coding",0]]
library(EnsDb.Hsapiens.v86)
edb <- EnsDb.Hsapiens.v86
## Get the TwoBit with the genomic sequence matching the Ensembl version
## using the AnnotationHub package.
dna <- ensembldb:::getGenomeTwoBitFile(edb)
## Get start/end coordinates of all genes.
genes <- genes(edb)
## Subset to all genes that are encoded on chromosomes for which
## we do have DNA sequence available.
genes <- genes[seqnames(genes) %in% seqnames(seqinfo(dna))]
## Get the gene sequences, i.e. the sequence including the sequence of
## all of the gene's exons and introns.
geneSeqs <- getSeq(dna, genes)
library(EnsDb.Hsapiens.v86)
BiocManager::install("EnsDb.Hsapiens.v86")
library(EnsDb.Hsapiens.v86)
edb <- EnsDb.Hsapiens.v86
## Get the TwoBit with the genomic sequence matching the Ensembl version
## using the AnnotationHub package.
dna <- ensembldb:::getGenomeTwoBitFile(edb)
## Get start/end coordinates of all genes.
genes <- genes(edb)
genes <- genes[seqnames(genes) %in% seqnames(seqinfo(dna))]
## Get the gene sequences, i.e. the sequence including the sequence of
## all of the gene's exons and introns.
geneSeqs <- getSeq(dna, genes)
geneSeqs
tx2 <- tx[seqnames(tx) %in% seqnames(seqinfo(genome))]
tx2
tx
genome[tx2]
tx
tx2
tx
grexpand(tx2)
GenomicRanges::ranges()
GenomicRanges::ranges(tx2)
reduce(tx2)
rr <- reduce(tx2)
genome[rr]
genome.out <- paste0("customGenome.fasta", ifelse(isCompressed, ".gz", ""))
isCompressed = T
genome.out <- paste0("customGenome.fasta", ifelse(isCompressed, ".gz", ""))
genome.out <- file.path(output_dir, genome.out)
writeXStringSet(genome, genome.out, compress = TRUE)
features <- readRDS("~/Desktop/features.rds")
devtools::load_all(".")
get_biotypes <- function(fe = features, pattern){
bt <- features[grep(pattern, x = features$tx_id),]
features[grep(pattern = paste(paste0("^", unique(bt$symbol)), collapse = "|"),
x = features$symbol),]
}
tRNA <- get_biotypes(pattern = "^tRNA-Gly|^tRNA-Glu|^tRNA-His")
piRNA <- get_biotypes(pattern = "pi-Il17rd.1|pi-Ctdsp2.3|pi-Ctdsp2.2|pi-Ctdsp2.1")
rRNA <- get_biotypes(pattern = "n-R5s124|n-R5s112|n-R5s33|n-R5s139")
snRNA <- get_biotypes(pattern = "ENSMUST00000101973|ENSMUST00000083435|ENSMUST00000178250")
snoRNA <- get_biotypes(pattern = "ENSMUST00000083347|ENSMUST00000083262|ENSMUST00000199023")
lincRNA <- get_biotypes(pattern = "Gm45702|Gm10685|Gm11290")
pc <- get_biotypes(pattern = "Kitl|Vac14|Pou6f2")
miRNA <- get_biotypes(pattern = "miR-10|miR-191-|miR-99|miR-30a")
gr <- c(miRNA, pc, tRNA, piRNA, rRNA, lincRNA, snRNA, snoRNA)
gr
tRNA
db_mmu <- getDB()
ensdb <- db_mmu$ensdb
db <- filter(ensdb, filter = ~ symbol %in% gr$symbol)
db
gr$tx_id
db <- filter(ensdb, filter = ~ tx_name %in% gr$tx_id)
db
db <- filter(ensdb, filter = ~ symbol %in% gr$symbol)
db
db <- filter(ensdb, filter = ~ tx_name %in% gr$tx_id)
db_mmu$tRNA_fa
db_mmu$tRNA_fa[names(db_mmu$tRNA_fa) %in% gr$symbol]
tRNA
db_mmu$tRNA_fa <- db_mmu$tRNA_fa[names(db_mmu$tRNA_fa) %in% gr$symbol]
db_mmu$rRNA_fa[names(db_mmu$rRNA_fa) %in% gr$symbol]
db_mmu$rRNA_fa <- db_mmu$rRNA_fa[names(db_mmu$rRNA_fa) %in% gr$symbol]
ensdb = db
mm10_annoprep <- prepareAnnotation(
ensdb = db,
# genome = "/mnt/IM/reference/genome/gencode/fasta/GRCm38.p5.genome.fa",
output_dir = "~/Desktop",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
output_dir = "~/Desktop"
db_mmu$miRNA_GR
db_mmu$miRNA_GR[db_mmu$miRNA_GR$symbol %in% gr$symbol]
pc
miRNA
piRNA
db_mmu$miRNA_GR <- db_mmu$miRNA_GR[db_mmu$miRNA_GR$symbol %in% gr$symbol]
db_mmu$piRNA_GR <- db_mmu$piRNA_GR[db_mmu$piRNA_GR$symbol %in% gr$symbol]
db_mmu$piRNA_GR
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR)
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa)
resolveSplicing = NULL
rules = defaultAssignRules()
tRNAEnsembleRemove = TRUE
clusterMiRNA = TRUE
# Loading libraries early in case they are not available,
# program will fail early
library(dplyr)
library(ensembldb)
library(R.utils)
library(Rsubread)
if (!dir.exists(output_dir)) dir.create(output_dir)
# If splicing is not to be resolved
if (is.null(resolveSplicing)) {
p <- rules$priorities
resolveSplicing <- names(p)[p >= 0]
}
# If splicing is to be resolved
if (!is.null(resolveSplicing)) {
gs <- genes(ensdb,
filter = ~ tx_biotype != resolveSplicing,
columns = c("tx_id", "gene_id", "gene_biotype", "symbol")
)
gs$tx_id <- gs$symbol
gs$tx_biotype <- gs$gene_biotype
gs$gene_id <- gs$gene_biotype <- NULL
gs <- unique(gs)
anofilter <- ~ tx_biotype == resolveSplicing
} else {
anofilter <- NULL
}
tx <- exonsBy(ensdb,
filter = anofilter,
columns = c("tx_id", "tx_biotype", "symbol")
)
tx <- unlist(tx)
tx
tx$tx_biotype
gr
gr$tx_biotype
if ("tRNA" %in% names(extra.seqs) & tRNAEnsembleRemove) {
tx <- tx[grep("tRNA", tx$tx_biotype, invert = T)]
}
tx$tx_biotype[tx$tx_biotype == "miRNA"] <- ifelse(
test = width(tx[tx$tx_biotype == "miRNA"]) > 25,
yes = "miRNA_precursor", no = "miRNA"
)
# If additional sequence files are provided
if (!is.null(extra.seqs)) {
stopifnot(is.list(extra.seqs) || is(extra.seqs, "DNAStringSet"))
# If additional sequence files are provided as a list
if (is.list(extra.seqs)) {
m <- dplyr::bind_rows(
lapply(extra.seqs, FUN = function(x) {
data.frame(
row.names = names(x), tx_id = names(x),
seq = as.character(x)
)
}),
.id = "tx_biotype"
)
extra.seqs <- DNAStringSet(m$seq)
m$seq <- NULL
names(extra.seqs) <- row.names(m)
mcols(extra.seqs) <- m
}
m <- mcols(extra.seqs)
if (is.null(m$tx_id)) m$tx_id <- names(extra.seqs)
names(extra.seqs) <- paste0("pseudoChr_", names(extra.seqs))
stopifnot(all(c("tx_id", "tx_biotype") %in% colnames(mcols(extra.seqs))))
if (is.null(m$symbol)) m$symbol <- m$tx_id
gr <- GRanges(names(extra.seqs), IRanges(1L, width = nchar(extra.seqs)),
strand = "+", tx_id = m$tx_id, tx_biotype = m$tx_biotype,
symbol = m$symbol
)
}
if (!is.null(resolveSplicing)) tx <- c(tx, gs)
if (!is.null(extra.seqs)) tx <- c(tx, gr)
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_biotype"] <- "tx_type"
if (length(extra.gr) > 0) {
extra.gr1 <- lapply(names(extra.gr), FUN = function(x) {
gr <- extra.gr[[x]]
seqlevelsStyle(gr) <- "ensembl"
if (is(gr, "GRangesList")) {
stopifnot(!is.null(names(gr)))
if (!("tx_type" %in% colnames(gr@unlistData))) {
gr@unlistData$tx_biotype <- x
}
if (!("symbol" %in% colnames(gr@unlistData))) {
gr@unlistData$symbol <- gr@unlistData$tx_id
}
gr@unlistData <- gr@unlistData[, c("tx_id", "tx_type", "symbol")]
} else {
stopifnot("tx_id" %in% colnames(mcols(gr)))
if (!("tx_type" %in% colnames(mcols(gr)))) mcols(gr)$tx_biotype <- x
if (!("symbol" %in% colnames(mcols(gr)))) mcols(gr)$symbol <- x
if (!is.null(gr$type) && any(gr$type == "exon")) gr <- gr$exon
mcols(gr) <- mcols(gr)[, c("tx_id", "tx_type", "symbol")]
# gr <- split(gr, gr$tx_id)
}
return(gr)
})
tx2 <- tx[!overlapsAny(tx, do.call(c, extra.gr1))]
tx <- c(tx2, do.call(c, extra.gr1))
anno.out <- file.path(output_dir, "features.rds")
}
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_type"] <- "tx_biotype"
names(tx) <- NULL
tx2 <- tx[grep("miRNA", tx$tx_biotype, invert = TRUE)]
tx3 <- tx[grep("miRNA", tx$tx_biotype)]
tx4 <- tx3[startsWith(tx3$symbol, "Mir")]
tx3 <- tx3[!startsWith(tx3$symbol, "Mir")]
tx4$symbol1 <- paste(tx4$symbol, tx4$tx_id, sep = "_")
tx4$tx_id1 <- tx4$symbol
tx4$tx_id1 <- gsub("Mir", "miR-", tx4$tx_id1)
tx4$symbol <- tx4$symbol1
tx4$tx_id <- tx4$tx_id1
tx4 <- tx4[, c("tx_id", "tx_biotype", "symbol")]
tx <- Reduce(c, list(tx2, tx3, tx4))
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
if (clusterMiRNA) tx <- miRNAcluster(tx)
tx
tx$tx_biotype
unique(tx$tx_biotype)
anno.out
output_dir
output_dir = "~/Desktop/data_sh"
if (!dir.exists(output_dir)) dir.create(output_dir)
anno.out <- file.path(output_dir, "features.rds")
anno.out
saveRDS(tx, file = anno.out)
message("Features saved in \n", anno.out)
# If genome is not provided
if (is.null(genome)) genome <- getSeq(ensembldb::getGenomeTwoBitFile(ensdb))
genome
ensdb = db
ensdb
if (!dir.exists(output_dir)) dir.create(output_dir)
# If splicing is not to be resolved
if (is.null(resolveSplicing)) {
p <- rules$priorities
resolveSplicing <- names(p)[p >= 0]
}
# If splicing is to be resolved
if (!is.null(resolveSplicing)) {
gs <- genes(ensdb,
filter = ~ tx_biotype != resolveSplicing,
columns = c("tx_id", "gene_id", "gene_biotype", "symbol")
)
gs$tx_id <- gs$symbol
gs$tx_biotype <- gs$gene_biotype
gs$gene_id <- gs$gene_biotype <- NULL
gs <- unique(gs)
anofilter <- ~ tx_biotype == resolveSplicing
} else {
anofilter <- NULL
}
tx <- exonsBy(ensdb,
filter = anofilter,
columns = c("tx_id", "tx_biotype", "symbol")
)
tx <- unlist(tx)
if ("tRNA" %in% names(extra.seqs) & tRNAEnsembleRemove) {
tx <- tx[grep("tRNA", tx$tx_biotype, invert = T)]
}
tx$tx_biotype[tx$tx_biotype == "miRNA"] <- ifelse(
test = width(tx[tx$tx_biotype == "miRNA"]) > 25,
yes = "miRNA_precursor", no = "miRNA"
)
# If additional sequence files are provided
if (!is.null(extra.seqs)) {
stopifnot(is.list(extra.seqs) || is(extra.seqs, "DNAStringSet"))
# If additional sequence files are provided as a list
if (is.list(extra.seqs)) {
m <- dplyr::bind_rows(
lapply(extra.seqs, FUN = function(x) {
data.frame(
row.names = names(x), tx_id = names(x),
seq = as.character(x)
)
}),
.id = "tx_biotype"
)
extra.seqs <- DNAStringSet(m$seq)
m$seq <- NULL
names(extra.seqs) <- row.names(m)
mcols(extra.seqs) <- m
}
m <- mcols(extra.seqs)
if (is.null(m$tx_id)) m$tx_id <- names(extra.seqs)
names(extra.seqs) <- paste0("pseudoChr_", names(extra.seqs))
stopifnot(all(c("tx_id", "tx_biotype") %in% colnames(mcols(extra.seqs))))
if (is.null(m$symbol)) m$symbol <- m$tx_id
gr <- GRanges(names(extra.seqs), IRanges(1L, width = nchar(extra.seqs)),
strand = "+", tx_id = m$tx_id, tx_biotype = m$tx_biotype,
symbol = m$symbol
)
}
if (!is.null(resolveSplicing)) tx <- c(tx, gs)
if (!is.null(extra.seqs)) tx <- c(tx, gr)
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_biotype"] <- "tx_type"
if (length(extra.gr) > 0) {
extra.gr1 <- lapply(names(extra.gr), FUN = function(x) {
gr <- extra.gr[[x]]
seqlevelsStyle(gr) <- "ensembl"
if (is(gr, "GRangesList")) {
stopifnot(!is.null(names(gr)))
if (!("tx_type" %in% colnames(gr@unlistData))) {
gr@unlistData$tx_biotype <- x
}
if (!("symbol" %in% colnames(gr@unlistData))) {
gr@unlistData$symbol <- gr@unlistData$tx_id
}
gr@unlistData <- gr@unlistData[, c("tx_id", "tx_type", "symbol")]
} else {
stopifnot("tx_id" %in% colnames(mcols(gr)))
if (!("tx_type" %in% colnames(mcols(gr)))) mcols(gr)$tx_biotype <- x
if (!("symbol" %in% colnames(mcols(gr)))) mcols(gr)$symbol <- x
if (!is.null(gr$type) && any(gr$type == "exon")) gr <- gr$exon
mcols(gr) <- mcols(gr)[, c("tx_id", "tx_type", "symbol")]
# gr <- split(gr, gr$tx_id)
}
return(gr)
})
tx2 <- tx[!overlapsAny(tx, do.call(c, extra.gr1))]
tx <- c(tx2, do.call(c, extra.gr1))
anno.out <- file.path(output_dir, "features.rds")
}
colnames(mcols(tx))[colnames(mcols(tx)) == "tx_type"] <- "tx_biotype"
names(tx) <- NULL
tx2 <- tx[grep("miRNA", tx$tx_biotype, invert = TRUE)]
tx3 <- tx[grep("miRNA", tx$tx_biotype)]
tx4 <- tx3[startsWith(tx3$symbol, "Mir")]
tx3 <- tx3[!startsWith(tx3$symbol, "Mir")]
tx4$symbol1 <- paste(tx4$symbol, tx4$tx_id, sep = "_")
tx4$tx_id1 <- tx4$symbol
tx4$tx_id1 <- gsub("Mir", "miR-", tx4$tx_id1)
tx4$symbol <- tx4$symbol1
tx4$tx_id <- tx4$tx_id1
tx4 <- tx4[, c("tx_id", "tx_biotype", "symbol")]
tx <- Reduce(c, list(tx2, tx3, tx4))
tx <- tx[, c("tx_id", "tx_biotype", "symbol")]
if (clusterMiRNA) tx <- miRNAcluster(tx)
saveRDS(tx, file = anno.out)
message("Features saved in \n", anno.out)
# If genome is not provided
if (is.null(genome)) genome <- getSeq(ensembldb::getGenomeTwoBitFile(ensdb))
genome
ensdb
ensdb
genome <- getSeq(ensembldb::getGenomeTwoBitFile(db_mmu$ensdb))
genome = NULL
# If genome is not provided
if (is.null(genome)) genome <- getSeq(ensembldb::getGenomeTwoBitFile(ensdb))
class(genome)
gr
gr <- c(miRNA, pc, tRNA, piRNA, rRNA, lincRNA, snRNA, snoRNA)
gr
paste(seqnames(gr))
paste(seqnames(gr), ranges(gr))
paste(seqnames(gr), ranges(gr), sep = ":")
loc <- paste(seqnames(gr), ranges(gr), sep = ":")
loc <- loc[grep(pattern = "^pseu", x = loc, invert = T)]
loc
gr <- c(miRNA, pc, tRNA, piRNA, rRNA, lincRNA, snRNA, snoRNA)
loc <- reduce(gr)
loc <- paste(seqnames(gr), ranges(gr), sep = ":")
loc <- loc[grep(pattern = "^pseu", x = loc, invert = T)]
loc
write.table(x = loc, file = "~/Desktop/data_sh/loc.txt", sep = "\n")
write.table(x = loc, file = "~/Desktop/data_sh/loc.txt", sep = "\n", quote = F, row.names = F, col.names = F)
genome = "~/Desktop/data_sh/custom_genome.fa"
# If genome is not provided
if (is.null(genome)) genome <- getSeq(ensembldb::getGenomeTwoBitFile(ensdb))
if (is.character(genome) && length(genome) != 1) {
stop(
"`genome` should be the path to a fasta(.gz) file, or a ",
"BSgenome/TwoBitFile object"
)
}
if (is(genome, "TwoBitFile") || grepl(pattern = "\\.2bit", x = genome)) {
genome <- import(genome)
}
isCompressed <- !is.character(genome) || grepl("\\.gz$", genome)
genome.out <- paste0("customGenome.fasta", ifelse(isCompressed, ".gz", ""))
genome.out <- file.path(output_dir, genome.out)
genome.out
if (is.null(extra.seqs)) { # in case of no extra seq
if (!is.character(genome)) { # if genome is not a file
writeXStringSet(genome, genome.out, compress = TRUE)
} else { # if genome is a file
file.copy(genome, genome.out)
if (!isCompressed) R.utils::gzip(genome.out)
}
} else { # in case of extra seq
if (!is.character(genome)) { # if genome is not a file
genome <- c(genome, extra.seqs)
writeXStringSet(genome, genome.out, compress = TRUE)
} else { # If genome is a file
file.copy(genome, genome.out)
writeXStringSet(extra.seqs,
filepath = genome.out,
append = TRUE
)
if (!isCompressed) R.utils::gzip(genome.out)
}
}
rm(genome)
message(
"Genome including eventual extra chromosomes was saved in:\n",
genome.out, "\nNow building the index..."
)
BiocManager::install("Rsubread")
Rsubread::buildindex(
basename = paste0(output_dir, "/customGenome"),
reference = ifelse(test = isCompressed,
yes = genome.out,
no = paste0(genome.out, ".gz")
), ...
)
Rsubread::buildindex(
basename = paste0(output_dir, "/customGenome"),
reference = ifelse(test = isCompressed,
yes = genome.out,
no = paste0(genome.out, ".gz")
)
)
mm10_annoprep <- prepareAnnotation(
ensdb = db,
genome = "~/Desktop/data_sh/genome/custom_genome.fa",
output_dir = "~/Desktop/data_sh",
extra.gr = list(piRNA = db_mmu$piRNA_GR, miRNA = db_mmu$miRNA_GR),
extra.seqs = list(rRNA = db_mmu$rRNA_fa, tRNA = db_mmu$tRNA_fa),
resolveSplicing = NULL,
rules = defaultAssignRules(),
tRNAEnsembleRemove = TRUE,
clusterMiRNA = TRUE
)
url <- "https://raw.githubusercontent.com/dktanwar/sperm_GSE162112/main/shortRNA/03_tse/"
o <- readRDS(url(paste0(url, "align/overlapBAM.rds")))
o
head(o)
ar <- readRDS(url(paste0(url, "align/assignedReads.rds")))
ar
o[o$transcript_id %in% gr$tx_id,]
os <- o[o$transcript_id %in% gr$tx_id,]
class(os)
GenomicAlignments::GAlignments(o)
GenomicAlignments::GAlignments(os)
ar
ar[any(ar$transcript_id) %in% gr$tx_id,]
ars <- ar[any(ar$transcript_id) %in% gr$tx_id,]
ar$transcript_id
ars <- ar[any(ar$transcript_id %in% gr$tx_id),]
ars
ars$alignment
aln <- unlist(ars$alignment)
aln
aln <- reduce(unlist(ars$alignment))
aln
aln <- unlist(ars$alignment)
library(GenomicAlignments)
bam <- readGAlignments(url(paste0(url, "align/unique.bam")))
bam <- readGAlignments("~/Desktop/data_sh/align/unique.bam")
bam
aln
subsetByOverlaps(bam, aln)
sbam <- subsetByOverlaps(bam, aln)
sbam <- subsetByOverlaps(bam, aln)
sbam
sbam
gr
db
ars
aln <- unlist(ars$alignment)
aln
